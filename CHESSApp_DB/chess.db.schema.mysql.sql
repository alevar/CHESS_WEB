-- MySQL Script generated by MySQL Workbench
-- Sat Oct  7 01:48:12 2023
-- Model: New Model    Version: 1.0
-- MySQL Workbench Forward Engineering

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';

-- -----------------------------------------------------
-- Schema CHESS_DB
-- -----------------------------------------------------
DROP SCHEMA IF EXISTS `CHESS_DB` ;

-- -----------------------------------------------------
-- Schema CHESS_DB
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `CHESS_DB` ;
USE `CHESS_DB` ;

-- -----------------------------------------------------
-- Table `CHESS_DB`.`Organisms`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`Organisms` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`Organisms` (
  `scientificName` VARCHAR(45) NOT NULL,
  `commonName` VARCHAR(45) NOT NULL,
  `information` TEXT NULL,
  UNIQUE INDEX `name_UNIQUE` (`commonName` ASC) VISIBLE,
  PRIMARY KEY (`scientificName`),
  UNIQUE INDEX `scientificName_UNIQUE` (`scientificName` ASC) VISIBLE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `CHESS_DB`.`Assemblies`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`Assemblies` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`Assemblies` (
  `assemblyName` VARCHAR(45) NOT NULL,
  `information` TEXT NOT NULL,
  `link` TEXT NOT NULL,
  `organismName` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`assemblyName`),
  UNIQUE INDEX `organismID_UNIQUE` (`assemblyName` ASC) VISIBLE,
  INDEX `fk_Assembly_organismName_idx` (`organismName` ASC) VISIBLE,
  CONSTRAINT `fk_Assembly_organismName`
    FOREIGN KEY (`organismName`)
    REFERENCES `CHESS_DB`.`Organisms` (`scientificName`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB
COMMENT = 'Genome Assembly information.';


-- -----------------------------------------------------
-- Table `CHESS_DB`.`SequenceIDs`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`SequenceIDs` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`SequenceIDs` (
  `assemblyName` VARCHAR(45) NOT NULL,
  `sequenceID` VARCHAR(45) NOT NULL,
  `length` INT UNSIGNED NOT NULL,
  `nomenclature` VARCHAR(45) NOT NULL COMMENT 'For cases where alternative naming schemes exist for the same assembly, the nomenclature allows one to distinguish between them',
  PRIMARY KEY (`assemblyName`, `sequenceID`),
  INDEX `sequenceID` (`sequenceID` ASC) VISIBLE,
  CONSTRAINT `fk_SequenceIDs_assembly`
    FOREIGN KEY (`assemblyName`)
    REFERENCES `CHESS_DB`.`Assemblies` (`assemblyName`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB
COMMENT = 'Describes a set of possible sequence IDs for a given assembly.\nWhen adding transcript records - we check against this to make sure all records are on available sequences.\nIf multiple nomenclatures exist for a given assembly - SequenceIDMap should be used to link them together.';


-- -----------------------------------------------------
-- Table `CHESS_DB`.`Transcripts`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`Transcripts` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`Transcripts` (
  `tid` INT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'tid is arbitrary number. It can represent multiple transcript_ids (merged into the record from multiple sources)',
  `assemblyName` VARCHAR(45) NOT NULL,
  `sequenceID` VARCHAR(45) NOT NULL,
  `strand` BIT NOT NULL,
  `start` INT UNSIGNED NOT NULL,
  `end` INT UNSIGNED NOT NULL,
  `exons` TEXT NOT NULL,
  `lastUpdated` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`tid`),
  UNIQUE INDEX `tid_UNIQUE` (`tid` ASC) VISIBLE,
  INDEX `fk_Transcripts_sequenceID_idx` (`sequenceID` ASC, `assemblyName` ASC) VISIBLE,
  CONSTRAINT `fk_Transcripts_sequenceID`
    FOREIGN KEY (`sequenceID` , `assemblyName`)
    REFERENCES `CHESS_DB`.`SequenceIDs` (`sequenceID` , `assemblyName`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `CHESS_DB`.`Sources`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`Sources` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`Sources` (
  `sourceID` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(45) NOT NULL,
  `information` TEXT NOT NULL,
  `link` TEXT NOT NULL,
  `originalFormat` ENUM("gtf", "gff") NOT NULL,
  `lastUpdated` VARCHAR(45) NULL,
  PRIMARY KEY (`sourceID`),
  UNIQUE INDEX `sourceID_UNIQUE` (`sourceID` ASC) VISIBLE,
  UNIQUE INDEX `name_UNIQUE` (`name` ASC) VISIBLE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `CHESS_DB`.`Genes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`Genes` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`Genes` (
  `gid` VARCHAR(50) NOT NULL,
  `name` VARCHAR(45) NOT NULL,
  `type` ENUM("protein_coding", "lncRNA", "ncRNA", "miscRNA", "antisenseRNA") NOT NULL,
  `description` TEXT NULL,
  `sourceID` INT UNSIGNED NOT NULL COMMENT 'Unlike for transcripts where we can establish equality between two isoforms, telling that two genes are the same is much more difficult.\nHence we keep all gene records without deduplicating them. As a sideeffect, we do not need to store a many-to-many relationship to the Sources like we do with Transcripts.\nSince every gene in a catalog is added as a separate record, the source can be listed directly as a foreign key instead.\nHowever a transcript-to-gene many-to-many relatioship is used instead.',
  PRIMARY KEY (`gid`),
  UNIQUE INDEX `gid_UNIQUE` (`gid` ASC) VISIBLE,
  INDEX `fk_Genes_source_idx` (`sourceID` ASC) VISIBLE,
  INDEX `type` (`type` ASC) VISIBLE,
  CONSTRAINT `fk_Genes_source`
    FOREIGN KEY (`sourceID`)
    REFERENCES `CHESS_DB`.`Sources` (`sourceID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `CHESS_DB`.`TranscriptToGene`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`TranscriptToGene` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`TranscriptToGene` (
  `tid` INT UNSIGNED NOT NULL,
  `gid` VARCHAR(50) NOT NULL,
  PRIMARY KEY (`tid`, `gid`),
  INDEX `fk_TranscriptToGene_gid_idx` (`gid` ASC) VISIBLE,
  CONSTRAINT `fk_TranscriptToGene_tid`
    FOREIGN KEY (`tid`)
    REFERENCES `CHESS_DB`.`Transcripts` (`tid`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_TranscriptToGene_gid`
    FOREIGN KEY (`gid`)
    REFERENCES `CHESS_DB`.`Genes` (`gid`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB
COMMENT = 'Single tid can be assigned to multiple genes (from different sources) but to a single gene only from a single source.\nA gene can link to multiple transcripts both within and between sources.';


-- -----------------------------------------------------
-- Table `CHESS_DB`.`Datasets`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`Datasets` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`Datasets` (
  `datasetID` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(45) NOT NULL,
  `sampleCount` INT NOT NULL COMMENT 'total number of samples in the dataset',
  `information` TEXT NOT NULL,
  PRIMARY KEY (`datasetID`),
  UNIQUE INDEX `datasetID_UNIQUE` (`datasetID` ASC) VISIBLE,
  UNIQUE INDEX `name_UNIQUE` (`name` ASC) VISIBLE)
ENGINE = InnoDB
COMMENT = 'Holds information about RNAseq datasets which can be added to store expression data and possibly other information about transcripts \nbased on the sequencing data available';


-- -----------------------------------------------------
-- Table `CHESS_DB`.`TranscriptToDataset`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`TranscriptToDataset` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`TranscriptToDataset` (
  `tid` INT UNSIGNED NOT NULL,
  `datasetID` INT UNSIGNED NOT NULL,
  `sampleCount` INT UNSIGNED NOT NULL,
  `expressionMean` FLOAT NOT NULL,
  `expressionStd` FLOAT NOT NULL,
  PRIMARY KEY (`tid`, `datasetID`),
  INDEX `fk_TranscriptToDataset_dataset_idx` (`datasetID` ASC) VISIBLE,
  INDEX `sampleCount` (`sampleCount` ASC) VISIBLE,
  INDEX `expressionMean` (`expressionMean` ASC) VISIBLE,
  CONSTRAINT `fk_TranscriptToDataset_tid`
    FOREIGN KEY (`tid`)
    REFERENCES `CHESS_DB`.`Transcripts` (`tid`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_TranscriptToDataset_dataset`
    FOREIGN KEY (`datasetID`)
    REFERENCES `CHESS_DB`.`Datasets` (`datasetID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB
COMMENT = 'stores expression data for the transcripts and links it to the information about the dataset that generated corroborating data';


-- -----------------------------------------------------
-- Table `CHESS_DB`.`TxDBXREF`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`TxDBXREF` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`TxDBXREF` (
  `tid` INT UNSIGNED NOT NULL,
  `sourceID` INT UNSIGNED NOT NULL,
  `transcript_id` VARCHAR(50) NOT NULL,
  `type` ENUM("protein_coding", "non_coding", "antisense") NULL,
  `cds` TEXT NULL,
  `start` INT UNSIGNED NOT NULL COMMENT 'prime3 and prime5 (3\' and 5\') are coordinates specific to the version of the transcript on this particular source',
  `end` INT UNSIGNED NOT NULL COMMENT 'start and end (5\' and 3\') are coordinates specific to the version of the transcript on this particular source.\nThe main entry for the tid in Transcripts extends to the farthest ends of referencing transcripts.',
  `score` SMALLINT UNSIGNED NULL,
  PRIMARY KEY (`tid`, `sourceID`, `transcript_id`),
  INDEX `fk_TxDBXREF_source_idx` (`sourceID` ASC) VISIBLE,
  INDEX `type` (`type` ASC) VISIBLE,
  CONSTRAINT `fk_TxDBXREF_tid`
    FOREIGN KEY (`tid`)
    REFERENCES `CHESS_DB`.`Transcripts` (`tid`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_TxDBXREF_source`
    FOREIGN KEY (`sourceID`)
    REFERENCES `CHESS_DB`.`Sources` (`sourceID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB
COMMENT = 'This table is used to build a transcript map between sources.\nFor a transcript we can tell all sources and corresponding ID for each along with additional information that may vary from source to source.\nWhile the Transcripts table provides a high-level overview of the transcripts, deduplicating many entries and hiding some of the information';


-- -----------------------------------------------------
-- Table `CHESS_DB`.`Attributes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`Attributes` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`Attributes` (
  `tid` INT UNSIGNED NOT NULL,
  `sourceID` INT UNSIGNED NOT NULL,
  `transcript_id` VARCHAR(45) NOT NULL,
  `name` VARCHAR(45) NOT NULL,
  `value` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`tid`, `sourceID`, `name`, `transcript_id`),
  INDEX `fk_Attributes_tidsource_idx` (`tid` ASC, `sourceID` ASC, `transcript_id` ASC) VISIBLE,
  CONSTRAINT `fk_Attributes_tidsource`
    FOREIGN KEY (`tid` , `sourceID` , `transcript_id`)
    REFERENCES `CHESS_DB`.`TxDBXREF` (`tid` , `sourceID` , `transcript_id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB
COMMENT = 'Table listing all possible attribute keys stored across all datasets.\nAutoupdates timestamps in the transcripts on insert/update via triggers.';


-- -----------------------------------------------------
-- Table `CHESS_DB`.`SequenceIDMap`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`SequenceIDMap` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`SequenceIDMap` (
  `assemblyName` VARCHAR(45) NOT NULL,
  `sequenceID_1` VARCHAR(45) NOT NULL,
  `sequenceID_2` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`assemblyName`, `sequenceID_1`, `sequenceID_2`),
  INDEX `fk_SequenceIDMap_sequenceID1_idx` (`sequenceID_1` ASC) VISIBLE,
  INDEX `fk_SequenceIDMap_sequenceID2_idx` (`sequenceID_2` ASC) VISIBLE,
  CONSTRAINT `fk_SequenceIDMap_assembly`
    FOREIGN KEY (`assemblyName`)
    REFERENCES `CHESS_DB`.`SequenceIDs` (`assemblyName`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_SequenceIDMap_sequenceID1`
    FOREIGN KEY (`sequenceID_1`)
    REFERENCES `CHESS_DB`.`SequenceIDs` (`sequenceID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_SequenceIDMap_sequenceID2`
    FOREIGN KEY (`sequenceID_2`)
    REFERENCES `CHESS_DB`.`SequenceIDs` (`sequenceID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB
COMMENT = 'Conversion table between different nomenclatures of the same assembly.\nProvides a map between different names of the same sequence on the same assembly.';

USE `CHESS_DB`;

DELIMITER $$

USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`Transcripts_checkCoordinates_BEFORE_INSERT` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`Transcripts_checkCoordinates_BEFORE_INSERT` BEFORE INSERT ON `Transcripts` FOR EACH ROW
BEGIN
	-- Verifies validity of coordinates
    -- Check that sequenceID is valid for the given assembly
    -- Checks that coordinates are within bounds for that sequence
    -- Checks that start < end
    DECLARE sequenceCount INT;
    DECLARE sequenceLength INT;
    
    SELECT COUNT(*) INTO sequenceCount
    FROM SequenceIDs
    WHERE assemblyName = NEW.assemblyName AND sequenceID = NEW.sequenceID;
    
    IF sequenceCount = 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'SequenceID does not exist for the specified assembly';
    END IF;
    
    IF sequenceCount > 0 THEN
        SELECT length INTO sequenceLength
        FROM SequenceIDs
        WHERE assemblyName = NEW.assemblyName AND sequenceID = NEW.sequenceID;
        
        IF NEW.start >= NEW.end THEN
			SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'start >= end';
		END IF;
        
        IF NEW.start < 1 OR NEW.start > sequenceLength OR NEW.end > sequenceLength THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Start and/or end coordinates are out of bounds for the specified sequence';
        END IF;
    END IF;
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`update_sources_lastUpdated_after_insert_in_Transcripts` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`update_sources_lastUpdated_after_insert_in_Transcripts` AFTER INSERT ON `Transcripts` FOR EACH ROW
BEGIN
	-- 'propagates lastUpdated to the Source through dbxref'
    UPDATE Sources
    SET lastUpdated = CURRENT_TIMESTAMP
    WHERE sourceID IN (SELECT sourceID FROM TxDBXREF WHERE tid = NEW.tid);
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`Transcripts_checkCoordinates_BEFORE_UPDATE` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`Transcripts_checkCoordinates_BEFORE_UPDATE` BEFORE UPDATE ON `Transcripts` FOR EACH ROW
BEGIN
	-- Verifies validity of coordinates
    -- Check that sequenceID is valid for the given assembly
    -- Checks that coordinates are within bounds for that sequence
    -- Checks that start < end
    DECLARE sequenceCount INT;
    DECLARE sequenceLength INT;
    
    SELECT COUNT(*) INTO sequenceCount
    FROM SequenceIDs
    WHERE assemblyName = NEW.assemblyName AND sequenceID = NEW.sequenceID;
    
    IF sequenceCount = 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'SequenceID does not exist for the specified assembly';
    END IF;
    
    IF sequenceCount > 0 THEN
        SELECT length INTO sequenceLength
        FROM SequenceIDs
        WHERE assemblyName = NEW.assemblyName AND sequenceID = NEW.sequenceID;
        
        IF NEW.start >= NEW.end THEN
			SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'start >= end';
		END IF;
        
        IF NEW.start < 1 OR NEW.start > sequenceLength OR NEW.end > sequenceLength THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Start and/or end coordinates are out of bounds for the specified sequence';
        END IF;
    END IF;
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`update_sources_lastUpdated_after_update_in_Transcripts` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`update_sources_lastUpdated_after_update_in_Transcripts` AFTER UPDATE ON `Transcripts` FOR EACH ROW
BEGIN
	-- 'propagates lastUpdated to the Source through dbxref'
    UPDATE Sources
    SET lastUpdated = CURRENT_TIMESTAMP
    WHERE sourceID IN (SELECT sourceID FROM TxDBXREF WHERE tid = NEW.tid);
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`update_sources_lastUpdated_after_delete_in_Transcripts` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`update_sources_lastUpdated_after_delete_in_Transcripts` AFTER DELETE ON `Transcripts` FOR EACH ROW
BEGIN
	-- 'propagates lastUpdated to the Source through dbxref'
    UPDATE Sources
    SET lastUpdated = CURRENT_TIMESTAMP
    WHERE sourceID IN (SELECT sourceID FROM TxDBXREF WHERE tid = OLD.tid);
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`TxDBXREF_setEnds_AFTER_INSERT` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`TxDBXREF_setEnds_AFTER_INSERT` AFTER INSERT ON `TxDBXREF` FOR EACH ROW
BEGIN
	-- updates record for the tid in Transcripts to extend towards the farthest 3' and 5' ends
    UPDATE Transcripts
    SET start = LEAST(NEW.start, (SELECT * FROM (SELECT start FROM Transcripts WHERE tid = NEW.tid) as TranscriptStart)),
        end = GREATEST(NEW.end, (SELECT * FROM (SELECT end FROM Transcripts WHERE tid = NEW.tid) as TranscriptEnd))
    WHERE tid = NEW.tid;
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`TxDBXREF_setEnds_AFTER_UPDATE` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`TxDBXREF_setEnds_AFTER_UPDATE` AFTER UPDATE ON `TxDBXREF` FOR EACH ROW
BEGIN
	-- updates record for the tid in Transcripts to extend towards the farthest 3' and 5' ends
    DECLARE min_start INT;
    DECLARE max_end INT;

    SELECT MAX(end) INTO max_end
    FROM TxDBXREF
    WHERE tid = NEW.tid;
    
    SELECT MIN(start) INTO min_start
    FROM TxDBXREF
    WHERE tid = NEW.tid;

    UPDATE Transcripts
    SET end = max_end
    WHERE tid = NEW.tid;
    
    UPDATE Transcripts
    SET start = min_start
    WHERE tid = NEW.tid;
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`Attributes_AFTER_INSERT` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`Attributes_AFTER_INSERT` AFTER INSERT ON `Attributes` FOR EACH ROW
BEGIN
	UPDATE Transcripts
    SET lastUpdated = CURRENT_TIMESTAMP
    WHERE tid = NEW.tid;
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`Attributes_AFTER_UPDATE` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`Attributes_AFTER_UPDATE` AFTER UPDATE ON `Attributes` FOR EACH ROW
BEGIN
    UPDATE Transcripts
    SET lastUpdated = CURRENT_TIMESTAMP
    WHERE tid = NEW.tid;
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`Attributes_AFTER_DELETE` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`Attributes_AFTER_DELETE` AFTER DELETE ON `Attributes` FOR EACH ROW
BEGIN
	UPDATE Transcripts
    SET lastUpdated = CURRENT_TIMESTAMP
    WHERE tid = OLD.tid;
END$$


DELIMITER ;
SET SQL_MODE = '';
DROP USER IF EXISTS chess_master;
SET SQL_MODE='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';
CREATE USER 'chess_master' IDENTIFIED BY 'qwerty';

GRANT ALL ON `CHESS_DB`.* TO 'chess_master';

SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;
