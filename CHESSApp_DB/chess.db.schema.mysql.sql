-- MySQL Script generated by MySQL Workbench
-- Mon Aug 11 02:13:36 2025
-- Model: New Model    Version: 1.0
-- MySQL Workbench Forward Engineering

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';

-- -----------------------------------------------------
-- Schema default_schema
-- -----------------------------------------------------
-- -----------------------------------------------------
-- Schema CHESS_DB
-- -----------------------------------------------------
DROP SCHEMA IF EXISTS `CHESS_DB` ;

-- -----------------------------------------------------
-- Schema CHESS_DB
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `CHESS_DB` ;
USE `CHESS_DB` ;

-- -----------------------------------------------------
-- Table `CHESS_DB`.`organism`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`organism` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`organism` (
  `taxonomy_id` INT UNSIGNED NOT NULL,
  `scientific_name` VARCHAR(45) NOT NULL,
  `common_name` VARCHAR(45) NOT NULL,
  `information` TEXT NULL DEFAULT NULL,
  UNIQUE INDEX `name_UNIQUE` (`common_name` ASC) VISIBLE,
  PRIMARY KEY (`taxonomy_id`),
  UNIQUE INDEX `scientificName_UNIQUE` (`scientific_name` ASC) VISIBLE,
  UNIQUE INDEX `organismID_UNIQUE` (`taxonomy_id` ASC) VISIBLE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `CHESS_DB`.`assembly`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`assembly` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`assembly` (
  `assembly_id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `assembly_name` VARCHAR(45) NOT NULL,
  `information` TEXT NOT NULL,
  `taxonomy_id` INT UNSIGNED NOT NULL,
  UNIQUE INDEX `assemblyID_UNIQUE` (`assembly_name` ASC) VISIBLE,
  INDEX `fk_Assembly_organismName_idx` (`taxonomy_id` ASC) VISIBLE,
  PRIMARY KEY (`assembly_id`),
  UNIQUE INDEX `aid_UNIQUE` (`assembly_id` ASC) VISIBLE,
  CONSTRAINT `fk_Assembly_taxonomy_id`
    FOREIGN KEY (`taxonomy_id`)
    REFERENCES `CHESS_DB`.`organism` (`taxonomy_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Genome Assembly information.';


-- -----------------------------------------------------
-- Table `CHESS_DB`.`sequence_id`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`sequence_id` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`sequence_id` (
  `sequence_id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `assembly_id` INT UNSIGNED NOT NULL,
  `length` INT UNSIGNED NOT NULL,
  `sequence_type` ENUM("primary", "other") NOT NULL DEFAULT 'primary',
  PRIMARY KEY (`sequence_id`),
  INDEX `fk_SequenceIDs_assembly_idx` (`assembly_id` ASC) VISIBLE,
  CONSTRAINT `fk_SequenceIDs_assembly`
    FOREIGN KEY (`assembly_id`)
    REFERENCES `CHESS_DB`.`assembly` (`assembly_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Describes a set of possible sequence IDs for a given assembly.\\nWhen adding transcript records - we check against this to make sure all records are on available sequences.\\nIf multiple nomenclatures exist for a given assembly - SequenceIDMap should be used to link them together.';


-- -----------------------------------------------------
-- Table `CHESS_DB`.`transcript`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`transcript` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`transcript` (
  `tid` INT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'tid is arbitrary number. It can represent multiple transcript_ids (merged into the record from multiple sources)',
  `sequence_id` INT UNSIGNED NOT NULL,
  `strand` BIT NOT NULL,
  `start` INT UNSIGNED NOT NULL,
  `end` INT UNSIGNED NOT NULL,
  `last_updated` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`tid`),
  UNIQUE INDEX `tid_UNIQUE` (`tid` ASC) VISIBLE,
  INDEX `fk_Transcript_sequenceID_idx` (`sequence_id` ASC) VISIBLE,
  CONSTRAINT `fk_Transcript_sequenceID`
    FOREIGN KEY (`sequence_id`)
    REFERENCES `CHESS_DB`.`sequence_id` (`sequence_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `CHESS_DB`.`source`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`source` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`source` (
  `source_id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(45) NOT NULL,
  `information` TEXT NOT NULL,
  `link` TEXT NOT NULL,
  `last_updated` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `citation` TEXT NOT NULL,
  PRIMARY KEY (`source_id`),
  UNIQUE INDEX `name_UNIQUE` (`name` ASC) VISIBLE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `CHESS_DB`.`source_version`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`source_version` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`source_version` (
  `sv_id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `source_id` INT UNSIGNED NOT NULL,
  `version_name` VARCHAR(45) NOT NULL,
  `last_updated` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `version_rank` INT NOT NULL,
  `information` TEXT NULL,
  PRIMARY KEY (`sv_id`),
  UNIQUE INDEX `sv_id_UNIQUE` (`sv_id` ASC) VISIBLE,
  INDEX `source_id_idx` (`source_id` ASC) VISIBLE,
  UNIQUE INDEX `rank_unique_per_source` (`source_id` ASC, `version_rank` ASC) VISIBLE,
  CONSTRAINT `source_id`
    FOREIGN KEY (`source_id`)
    REFERENCES `CHESS_DB`.`source` (`source_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `CHESS_DB`.`source_version_assembly`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`source_version_assembly` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`source_version_assembly` (
  `sva_id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `sv_id` INT UNSIGNED NOT NULL,
  `assembly_id` INT UNSIGNED NOT NULL,
  `last_updated` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `information` TEXT NULL,
  PRIMARY KEY (`sva_id`),
  INDEX `assembly_id_idx` (`assembly_id` ASC) VISIBLE,
  UNIQUE INDEX `sva_id_UNIQUE` (`sva_id` ASC) VISIBLE,
  UNIQUE INDEX `unique_sv_assembly` (`sv_id` ASC, `assembly_id` ASC) VISIBLE,
  CONSTRAINT `assembly_id`
    FOREIGN KEY (`assembly_id`)
    REFERENCES `CHESS_DB`.`assembly` (`assembly_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `sv_id`
    FOREIGN KEY (`sv_id`)
    REFERENCES `CHESS_DB`.`source_version` (`sv_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `CHESS_DB`.`gene`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`gene` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`gene` (
  `gid` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `sva_id` INT UNSIGNED NOT NULL COMMENT 'Unlike for transcripts where we can establish equality between two isoforms, telling that two genes are the same is much more difficult.\\nHence we keep all gene records without deduplicating them. As a sideeffect, we do not need to store a many-to-many relationship to the Sources like we do with Transcripts.\\nSince every gene in a catalog is added as a separate record, the source can be listed directly as a foreign key instead.\\nHowever a transcript-to-gene many-to-many relatioship is used instead.',
  `name` VARCHAR(512) NOT NULL,
  `type_key` VARCHAR(45) NOT NULL,
  `type_value` VARCHAR(512) CHARACTER SET 'ascii' COLLATE 'ascii_bin' NOT NULL,
  `gene_id` VARCHAR(512) NOT NULL DEFAULT 'gene_id as it appears in the gtf',
  PRIMARY KEY (`sva_id`, `gid`),
  UNIQUE INDEX `gid_UNIQUE` (`gid` ASC) VISIBLE,
  INDEX `fk_Genes_sva_idx` (`sva_id` ASC) VISIBLE,
  CONSTRAINT `fk_Genes_sva_id`
    FOREIGN KEY (`sva_id`)
    REFERENCES `CHESS_DB`.`source_version_assembly` (`sva_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `CHESS_DB`.`dataset`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`dataset` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`dataset` (
  `dataset_id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(45) NOT NULL,
  `description` TEXT NOT NULL,
  `data_type` VARCHAR(45) NULL,
  PRIMARY KEY (`dataset_id`),
  UNIQUE INDEX `dataset_id_UNIQUE` (`dataset_id` ASC) VISIBLE,
  UNIQUE INDEX `name_UNIQUE` (`name` ASC) VISIBLE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `CHESS_DB`.`tx_dbxref`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`tx_dbxref` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`tx_dbxref` (
  `tid` INT UNSIGNED NOT NULL,
  `sva_id` INT UNSIGNED NOT NULL,
  `start` INT UNSIGNED NOT NULL COMMENT 'prime3 and prime5 (3\\\' and 5\\\') are coordinates specific to the version of the transcript on this particular source',
  `end` INT UNSIGNED NOT NULL COMMENT 'start and end (5\\\' and 3\\\') are coordinates specific to the version of the transcript on this particular source.\\nThe main entry for the tid in Transcripts extends to the farthest ends of referencing transcripts.',
  `score` SMALLINT UNSIGNED NULL DEFAULT NULL,
  `type_key` VARCHAR(45) NOT NULL,
  `type_value` VARCHAR(512) CHARACTER SET 'ascii' COLLATE 'ascii_bin' NOT NULL,
  `cds_start` INT UNSIGNED NULL,
  `cds_end` INT UNSIGNED NULL,
  `gid` INT UNSIGNED NULL,
  `transcript_id` VARCHAR(512) NOT NULL,
  PRIMARY KEY (`tid`, `sva_id`, `transcript_id`),
  INDEX `fk_TxDBXREF_gene_idx` (`sva_id` ASC, `gid` ASC) VISIBLE,
  CONSTRAINT `fk_TxDBXREF_tid`
    FOREIGN KEY (`tid`)
    REFERENCES `CHESS_DB`.`transcript` (`tid`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `fk_TxDBXREF_sva_id`
    FOREIGN KEY (`sva_id`)
    REFERENCES `CHESS_DB`.`source_version_assembly` (`sva_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `fk_TxDBXREF_gene`
    FOREIGN KEY (`sva_id` , `gid`)
    REFERENCES `CHESS_DB`.`gene` (`sva_id` , `gid`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'This table is used to build a transcript map between sources.\\nFor a transcript we can tell all sources and corresponding ID for each along with additional information that may vary from source to source.\\nWhile the Transcripts table provides a high-level overview of the transcripts, deduplicating many entries and hiding some of the information';


-- -----------------------------------------------------
-- Table `CHESS_DB`.`transcript_data`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`transcript_data` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`transcript_data` (
  `td_id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `tid` INT UNSIGNED NOT NULL,
  `sva_id` INT UNSIGNED NOT NULL,
  `transcript_id` VARCHAR(512) NOT NULL,
  `dataset_id` INT UNSIGNED NOT NULL,
  `data` TEXT NOT NULL,
  PRIMARY KEY (`td_id`),
  INDEX `dataset_id_idx` (`dataset_id` ASC) VISIBLE,
  UNIQUE INDEX `td_id_UNIQUE` (`td_id` ASC) VISIBLE,
  INDEX `fk_transcriptData_txDBXREF_idx` (`tid` ASC, `sva_id` ASC, `transcript_id` ASC) VISIBLE,
  CONSTRAINT `dataset_id`
    FOREIGN KEY (`dataset_id`)
    REFERENCES `CHESS_DB`.`dataset` (`dataset_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `fk_transcriptData_txDBXREF`
    FOREIGN KEY (`tid` , `sva_id` , `transcript_id`)
    REFERENCES `CHESS_DB`.`tx_dbxref` (`tid` , `sva_id` , `transcript_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'stores expression data for the transcripts and links it to the information about the dataset that generated corroborating data';


-- -----------------------------------------------------
-- Table `CHESS_DB`.`tx_attribute`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`tx_attribute` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`tx_attribute` (
  `tid` INT UNSIGNED NOT NULL,
  `sva_id` INT UNSIGNED NOT NULL,
  `key_name` VARCHAR(45) NOT NULL,
  `transcript_id` VARCHAR(512) NOT NULL,
  `value_cat` VARCHAR(512) CHARACTER SET 'ascii' COLLATE 'ascii_bin' NOT NULL DEFAULT '',
  `value_text` TEXT NULL,
  PRIMARY KEY (`tid`, `sva_id`, `key_name`, `transcript_id`),
  INDEX `fk_Attributes_tid_sva_idx` (`tid` ASC, `sva_id` ASC, `transcript_id` ASC) VISIBLE,
  CONSTRAINT `fk_Attributes_tid_sva_id`
    FOREIGN KEY (`tid` , `sva_id` , `transcript_id`)
    REFERENCES `CHESS_DB`.`tx_dbxref` (`tid` , `sva_id` , `transcript_id`)
    ON DELETE CASCADE
    ON UPDATE NO ACTION)
ENGINE = InnoDB
COMMENT = 'Table listing all possible attribute keys stored across all datasets.\\nAutoupdates timestamps in the transcripts on insert/update via triggers.';


-- -----------------------------------------------------
-- Table `CHESS_DB`.`nomenclature`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`nomenclature` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`nomenclature` (
  `assembly_id` INT UNSIGNED NOT NULL,
  `nomenclature` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`assembly_id`, `nomenclature`),
  CONSTRAINT `fk_nomenclature_assembly`
    FOREIGN KEY (`assembly_id`)
    REFERENCES `CHESS_DB`.`assembly` (`assembly_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `CHESS_DB`.`sequence_id_map`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`sequence_id_map` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`sequence_id_map` (
  `assembly_id` INT UNSIGNED NOT NULL,
  `sequence_id` INT UNSIGNED NOT NULL COMMENT 'sequenceID must always be convertible to INT',
  `nomenclature` VARCHAR(45) NOT NULL COMMENT 'name of the nomenclature',
  `sequence_name` VARCHAR(255) NOT NULL COMMENT 'another name for the name',
  PRIMARY KEY (`assembly_id`, `nomenclature`, `sequence_id`),
  CONSTRAINT `fk_SequenceIDMap_assembly`
    FOREIGN KEY (`sequence_id`)
    REFERENCES `CHESS_DB`.`sequence_id` (`sequence_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `fk_sequenceIDMap_nomenclature`
    FOREIGN KEY (`assembly_id` , `nomenclature`)
    REFERENCES `CHESS_DB`.`nomenclature` (`assembly_id` , `nomenclature`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Conversion table between different nomenclatures of the same assembly.\\nProvides a map between different names of the same sequence on the same assembly.';


-- -----------------------------------------------------
-- Table `CHESS_DB`.`configurations`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`configurations` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`configurations` (
  `configuration_id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `active` ENUM('active') NULL,
  `description` TEXT NOT NULL,
  `organism_id` INT UNSIGNED NOT NULL,
  `assembly_id` INT UNSIGNED NOT NULL,
  `nomenclature` VARCHAR(45) NOT NULL,
  `source_id` INT UNSIGNED NOT NULL,
  `sv_id` INT UNSIGNED NOT NULL,
  `sequence_id` INT NOT NULL,
  `start` INT NOT NULL,
  `end` INT NOT NULL,
  PRIMARY KEY (`configuration_id`),
  UNIQUE INDEX `configuration_id_UNIQUE` (`configuration_id` ASC) VISIBLE,
  INDEX `organism_id_idx` (`organism_id` ASC) VISIBLE,
  INDEX `source_id_idx` (`source_id` ASC) VISIBLE,
  INDEX `sv_id_idx` (`sv_id` ASC) VISIBLE,
  INDEX `nomenclature_idx` (`assembly_id` ASC, `nomenclature` ASC) VISIBLE,
  UNIQUE INDEX `active_UNIQUE` (`active` ASC) VISIBLE,
  CONSTRAINT `fk_configurations_organism_id`
    FOREIGN KEY (`organism_id`)
    REFERENCES `CHESS_DB`.`organism` (`taxonomy_id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_configurations_source_id`
    FOREIGN KEY (`source_id`)
    REFERENCES `CHESS_DB`.`source` (`source_id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_configurations_sv_id`
    FOREIGN KEY (`sv_id`)
    REFERENCES `CHESS_DB`.`source_version` (`sv_id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_configurations_nomenclature`
    FOREIGN KEY (`assembly_id` , `nomenclature`)
    REFERENCES `CHESS_DB`.`nomenclature` (`assembly_id` , `nomenclature`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_configurations_assembly_id`
    FOREIGN KEY (`assembly_id`)
    REFERENCES `CHESS_DB`.`assembly` (`assembly_id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB
COMMENT = 'This table contains ready-to-use configurations which can be immediately transformed into a set of files.\\nThe simplest configuration would be to describe each source as it appeared in the input.\\nBut more sophisticated configurations can be created.';


-- -----------------------------------------------------
-- Table `CHESS_DB`.`intron`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`intron` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`intron` (
  `iid` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `sequence_id` INT UNSIGNED NOT NULL,
  `strand` VARCHAR(45) NOT NULL,
  `start` VARCHAR(45) NOT NULL,
  `end` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`iid`),
  UNIQUE INDEX `unique_intron_coordinates` (`sequence_id` ASC, `strand` ASC, `start` ASC, `end` ASC) VISIBLE,
  INDEX `fk_Intron_sequence_idx` (`sequence_id` ASC) VISIBLE,
  CONSTRAINT `fk_Intron_sequence`
    FOREIGN KEY (`sequence_id`)
    REFERENCES `CHESS_DB`.`sequence_id` (`sequence_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `CHESS_DB`.`transcript_intron`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`transcript_intron` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`transcript_intron` (
  `tid` INT UNSIGNED NOT NULL,
  `iid` INT UNSIGNED NOT NULL,
  PRIMARY KEY (`tid`, `iid`),
  INDEX `fk_TranscriptToIntron_iid_idx` (`iid` ASC) VISIBLE,
  CONSTRAINT `fk_TranscriptToIntron_tid`
    FOREIGN KEY (`tid`)
    REFERENCES `CHESS_DB`.`transcript` (`tid`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `fk_TranscriptToIntron_iid`
    FOREIGN KEY (`iid`)
    REFERENCES `CHESS_DB`.`intron` (`iid`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Maps introns to individual transcripts. Many-to-many. Used to extract intron chains for each transcript';


-- -----------------------------------------------------
-- Table `CHESS_DB`.`source_file`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`source_file` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`source_file` (
  `file_path` VARCHAR(512) NOT NULL,
  `sva_id` INT UNSIGNED NOT NULL,
  `assembly_id` INT UNSIGNED NOT NULL,
  `nomenclature` VARCHAR(45) NOT NULL,
  `filetype` VARCHAR(45) NOT NULL,
  `description` TEXT NULL,
  UNIQUE INDEX `file_path_UNIQUE` (`file_path` ASC) VISIBLE,
  PRIMARY KEY (`file_path`, `sva_id`),
  INDEX `nomenclature_idx` (`assembly_id` ASC, `nomenclature` ASC) VISIBLE,
  CONSTRAINT `sva_id`
    FOREIGN KEY (`sva_id`)
    REFERENCES `CHESS_DB`.`source_version_assembly` (`sva_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `nomenclature`
    FOREIGN KEY (`assembly_id` , `nomenclature`)
    REFERENCES `CHESS_DB`.`nomenclature` (`assembly_id` , `nomenclature`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `CHESS_DB`.`genome_file`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`genome_file` ;

CREATE TABLE IF NOT EXISTS `CHESS_DB`.`genome_file` (
  `genome_file_id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `assembly_id` INT UNSIGNED NOT NULL,
  `nomenclature` VARCHAR(45) NOT NULL,
  `file_path` VARCHAR(512) NOT NULL,
  PRIMARY KEY (`genome_file_id`),
  UNIQUE INDEX `file_path_UNIQUE` (`file_path` ASC) VISIBLE,
  INDEX `fk_GenomeFile_assembly_idx` (`assembly_id` ASC) VISIBLE,
  UNIQUE INDEX `nomenclature_UNIQUE` (`assembly_id` ASC, `nomenclature` ASC) VISIBLE,
  CONSTRAINT `fk_GenomeFile_assembly`
    FOREIGN KEY (`assembly_id`)
    REFERENCES `CHESS_DB`.`assembly` (`assembly_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `fk_GenomeFile_nomenclature`
    FOREIGN KEY (`assembly_id` , `nomenclature`)
    REFERENCES `CHESS_DB`.`nomenclature` (`assembly_id` , `nomenclature`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB;

USE `CHESS_DB` ;

-- -----------------------------------------------------
-- Placeholder table for view `CHESS_DB`.`latest_source_versions`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `CHESS_DB`.`latest_source_versions` (`sv_id` INT, `source_name` INT, `version_name` INT, `information` INT, `link` INT, `last_updated` INT, `version_rank` INT, `source_id` INT, `citation` INT, `sva_id` INT, `assembly_id` INT, `assembly_name` INT, `assembly_information` INT, `taxonomy_id` INT, `scientific_name` INT, `common_name` INT, `organism_information` INT, `file_path` INT, `nomenclature` INT, `filetype` INT, `file_description` INT);

-- -----------------------------------------------------
-- Placeholder table for view `CHESS_DB`.`all_source_versions`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `CHESS_DB`.`all_source_versions` (`source_id` INT, `source_name` INT, `information` INT, `link` INT, `citation` INT, `sv_id` INT, `version_name` INT, `last_updated` INT, `version_rank` INT, `sva_id` INT, `assembly_id` INT, `assembly_name` INT, `assembly_information` INT, `taxonomy_id` INT, `scientific_name` INT, `common_name` INT, `organism_information` INT, `file_path` INT, `nomenclature` INT, `filetype` INT, `file_description` INT, `gene_types` INT, `transcript_types` INT);

-- -----------------------------------------------------
-- Placeholder table for view `CHESS_DB`.`source_type_counts_view`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `CHESS_DB`.`source_type_counts_view` (`sva_id` INT, `feature_type` INT, `type_value` INT, `count` INT);

-- -----------------------------------------------------
-- View `CHESS_DB`.`latest_source_versions`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`latest_source_versions`;
DROP VIEW IF EXISTS `CHESS_DB`.`latest_source_versions` ;
USE `CHESS_DB`;
CREATE  OR REPLACE VIEW `CHESS_DB`.`latest_source_versions` AS
SELECT 
    sv.sv_id,
    s.name as source_name,
    sv.version_name,
    s.information,
    s.link,
    sv.last_updated,
    sv.version_rank,
    sv.source_id,
    s.citation,
    -- Assembly information
    sva.sva_id,
    sva.assembly_id,
    a.assembly_name,
    a.information as assembly_information,
    -- Organism information
    o.taxonomy_id,
    o.scientific_name,
    o.common_name,
    o.information as organism_information,
    -- File information (including new filetype)
    sf.file_path,
    sf.nomenclature,
    sf.filetype,
    sf.description as file_description
FROM `source_version` sv
JOIN `source` s ON sv.source_id = s.source_id
JOIN `source_version_assembly` sva ON sv.sv_id = sva.sv_id
JOIN `assembly` a ON sva.assembly_id = a.assembly_id
JOIN `organism` o ON a.taxonomy_id = o.taxonomy_id
LEFT JOIN `source_file` sf ON sva.sva_id = sf.sva_id AND sva.assembly_id = sf.assembly_id
WHERE sv.version_rank = (
    SELECT MAX(sv2.version_rank) 
    FROM `source_version` sv2 
    WHERE sv2.source_id = sv.source_id
);

-- -----------------------------------------------------
-- View `CHESS_DB`.`all_source_versions`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`all_source_versions`;
DROP VIEW IF EXISTS `CHESS_DB`.`all_source_versions` ;
USE `CHESS_DB`;
-- View for all versions with source names
CREATE  OR REPLACE VIEW `CHESS_DB`.`all_source_versions` AS
SELECT 
    s.source_id,
    s.name as source_name,
    s.information,
    s.link,
    s.citation,
    sv.sv_id,
    sv.version_name,
    COALESCE(sv.last_updated, s.last_updated) as last_updated,
    sv.version_rank,
    -- Assembly information
    sva.sva_id,
    sva.assembly_id,
    a.assembly_name,
    a.information as assembly_information,
    -- Organism information
    o.taxonomy_id,
    o.scientific_name,
    o.common_name,
    o.information as organism_information,
    -- File information (including new filetype)
    sf.file_path,
    sf.nomenclature,
    sf.filetype,
    sf.description as file_description,
    -- Feature types (aggregated and sorted)
    COALESCE(gene_types.types, '') as gene_types,
    COALESCE(transcript_types.types, '') as transcript_types
FROM `source` s
LEFT JOIN `source_version` sv ON s.source_id = sv.source_id
LEFT JOIN `source_version_assembly` sva ON sv.sv_id = sva.sv_id
LEFT JOIN `assembly` a ON sva.assembly_id = a.assembly_id
LEFT JOIN `organism` o ON a.taxonomy_id = o.taxonomy_id
LEFT JOIN `source_file` sf ON sva.sva_id = sf.sva_id AND sva.assembly_id = sf.assembly_id
-- Subquery for gene types
LEFT JOIN (
    SELECT 
        sva_id,
        GROUP_CONCAT(DISTINCT type_value ORDER BY type_value SEPARATOR ',') as types
    FROM `gene`
    GROUP BY sva_id
) gene_types ON sva.sva_id = gene_types.sva_id
-- Subquery for transcript types
LEFT JOIN (
    SELECT 
        sva_id,
        GROUP_CONCAT(DISTINCT type_value ORDER BY type_value SEPARATOR ',') as types
    FROM `tx_dbxref`
    GROUP BY sva_id
) transcript_types ON sva.sva_id = transcript_types.sva_id
ORDER BY s.name, sv.version_name, a.assembly_name, sf.file_path;

-- -----------------------------------------------------
-- View `CHESS_DB`.`source_type_counts_view`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CHESS_DB`.`source_type_counts_view`;
DROP VIEW IF EXISTS `CHESS_DB`.`source_type_counts_view` ;
USE `CHESS_DB`;
CREATE OR REPLACE VIEW `CHESS_DB`.`source_type_counts_view` AS
SELECT 
    -- Source and assembly identification
    sva.sva_id,
    
    -- Feature type and counts
    'transcript' as feature_type,
    COALESCE(txd.type_value, 'unknown') as type_value,
    COUNT(DISTINCT t.tid) as count
    
FROM `source_version_assembly` sva
LEFT JOIN `tx_dbxref` txd ON sva.sva_id = txd.sva_id
LEFT JOIN `transcript` t ON txd.tid = t.tid

WHERE txd.sva_id IS NOT NULL  -- Only include sources that have transcripts

GROUP BY 
    sva.sva_id,
    txd.type_value

UNION ALL

SELECT 
    -- Source and assembly identification  
    sva.sva_id,
    
    -- Feature type and counts
    'gene' as feature_type,
    COALESCE(g.type_value, 'unknown') as type_value,
    COUNT(DISTINCT g.gid) as count
    
FROM `source_version_assembly` sva
LEFT JOIN `gene` g ON sva.sva_id = g.sva_id

WHERE g.sva_id IS NOT NULL  -- Only include sources that have genes

GROUP BY 
    sva.sva_id,
    g.type_value

ORDER BY 
    sva_id,
    feature_type,
    type_value;
USE `CHESS_DB`;

DELIMITER $$

USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`transcript_checkCoordinates_BEFORE_INSERT` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`transcript_checkCoordinates_BEFORE_INSERT` BEFORE INSERT ON `transcript` FOR EACH ROW
BEGIN
	-- Verifies validity of coordinates
    -- Check that sequenceID is valid for the given assembly
    -- Checks that coordinates are within bounds for that sequence
    -- Checks that start < end
    DECLARE sequence_count INT;
    DECLARE sequence_length INT;
    
    SELECT COUNT(*) INTO sequence_count
    FROM sequence_id
    WHERE sequence_id = NEW.sequence_id;
    
    IF sequence_count = 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'sequence_id does not exist for the specified assembly';
    END IF;
    
    IF sequence_count > 0 THEN
        SELECT length INTO sequence_length
        FROM sequence_id
        WHERE sequence_id = NEW.sequence_id;
        
        IF NEW.start >= NEW.end THEN
			SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'start >= end';
		END IF;
        
        IF NEW.start < 1 OR NEW.start > sequence_length OR NEW.end > sequence_length THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Start and/or end coordinates are out of bounds for the specified sequence';
        END IF;
    END IF;
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`tx_ai_sources_last_updated` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`tx_ai_sources_last_updated` AFTER INSERT ON `transcript` FOR EACH ROW
BEGIN
	-- 'propagates lastUpdated to the Source through dbxref'
    UPDATE source_version
    SET last_updated = CURRENT_TIMESTAMP
    WHERE sv_id IN (SELECT sv_id FROM tx_dbxref WHERE tid = NEW.tid);
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`transcript_checkCoordinates_BEFORE_UPDATE` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`transcript_checkCoordinates_BEFORE_UPDATE` BEFORE UPDATE ON `transcript` FOR EACH ROW
BEGIN
	-- Verifies validity of coordinates
    -- Check that sequence_id is valid for the given assembly
    -- Checks that coordinates are within bounds for that sequence
    -- Checks that start < end
    DECLARE sequence_count INT;
    DECLARE sequence_length INT;
    
    SELECT COUNT(*) INTO sequence_count
    FROM sequence_id
    WHERE sequence_id = NEW.sequence_id;
    
    IF sequence_count = 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'sequence_id does not exist for the specified assembly';
    END IF;
    
    IF sequence_count > 0 THEN
        SELECT length INTO sequence_length
        FROM sequence_id
        WHERE sequence_id = NEW.sequence_id;
        
        IF NEW.start >= NEW.end THEN
			SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'start >= end';
		END IF;
        
        IF NEW.start < 1 OR NEW.start > sequence_length OR NEW.end > sequence_length THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Start and/or end coordinates are out of bounds for the specified sequence';
        END IF;
    END IF;
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`update_sources_last_updated_after_update_in_Transcript` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`update_sources_last_updated_after_update_in_Transcript` AFTER UPDATE ON `transcript` FOR EACH ROW
BEGIN
	-- 'propagates lastUpdated to the Source through dbxref'
    UPDATE source_version
    SET last_updated = CURRENT_TIMESTAMP
    WHERE sv_id IN (SELECT sv_id FROM tx_dbxref WHERE tid = NEW.tid);
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`update_sources_last_updated_after_delete_in_Transcript` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`update_sources_last_updated_after_delete_in_Transcript` AFTER DELETE ON `transcript` FOR EACH ROW
BEGIN
	-- 'propagates lastUpdated to the Source through dbxref'
    UPDATE source_version
    SET last_updated = CURRENT_TIMESTAMP
    WHERE sv_id IN (SELECT sv_id FROM tx_dbxref WHERE tid = OLD.tid);
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`tx_dbxref_setEnds_AFTER_INSERT` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`tx_dbxref_setEnds_AFTER_INSERT` AFTER INSERT ON `tx_dbxref` FOR EACH ROW
BEGIN
	-- updates record for the tid in Transcripts to extend towards the farthest 3' and 5' ends
    UPDATE transcript
    SET start = LEAST(NEW.start, (SELECT * FROM (SELECT start FROM transcript WHERE tid = NEW.tid) as transcript_start)),
        end = GREATEST(NEW.end, (SELECT * FROM (SELECT end FROM transcript WHERE tid = NEW.tid) as transcript_end))
    WHERE tid = NEW.tid;
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`tx_dbxref_update_source_version_assembly_AFTER_INSERT` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`tx_dbxref_update_source_version_assembly_AFTER_INSERT` 
AFTER INSERT ON `tx_dbxref` FOR EACH ROW
BEGIN
    -- Force update to trigger the cascade to parent source
    UPDATE source_version_assembly
    SET last_updated = CURRENT_TIMESTAMP
    WHERE sva_id = NEW.sva_id;
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`tx_dbxref_setEnds_AFTER_UPDATE` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`tx_dbxref_setEnds_AFTER_UPDATE` AFTER UPDATE ON `tx_dbxref` FOR EACH ROW
BEGIN
	-- updates record for the tid in Transcripts to extend towards the farthest 3' and 5' ends
    DECLARE min_start INT;
    DECLARE max_end INT;

    SELECT MAX(end) INTO max_end
    FROM tx_dbxref
    WHERE tid = NEW.tid;
    
    SELECT MIN(start) INTO min_start
    FROM tx_dbxref
    WHERE tid = NEW.tid;

    UPDATE transcript
    SET end = max_end
    WHERE tid = NEW.tid;
    
    UPDATE transcript
    SET start = min_start
    WHERE tid = NEW.tid;
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`tx_dbxref_update_source_version_assembly_AFTER_UPDATE` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`tx_dbxref_update_source_version_assembly_AFTER_UPDATE` AFTER UPDATE ON `tx_dbxref` FOR EACH ROW
BEGIN
    -- Force update to trigger the cascade to parent source
    UPDATE source_version_assembly
    SET last_updated = CURRENT_TIMESTAMP
    WHERE sva_id = NEW.sva_id;
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`tx_attribute_AI` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`tx_attribute_AI` AFTER INSERT ON `tx_attribute` FOR EACH ROW
BEGIN
	UPDATE transcript
    SET last_updated = CURRENT_TIMESTAMP
    WHERE tid = NEW.tid;
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`tx_attribute_AU` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`tx_attribute_AU` AFTER UPDATE ON `tx_attribute` FOR EACH ROW
BEGIN
    UPDATE transcript
    SET last_updated = CURRENT_TIMESTAMP
    WHERE tid = NEW.tid;
END$$


USE `CHESS_DB`$$
DROP TRIGGER IF EXISTS `CHESS_DB`.`tx_attribute_AD` $$
USE `CHESS_DB`$$
CREATE DEFINER = CURRENT_USER TRIGGER `CHESS_DB`.`tx_attribute_AD` AFTER DELETE ON `tx_attribute` FOR EACH ROW
BEGIN
	UPDATE transcript
    SET last_updated = CURRENT_TIMESTAMP
    WHERE tid = OLD.tid;
END$$


DELIMITER ;
SET SQL_MODE = '';
DROP USER IF EXISTS chess_master;
SET SQL_MODE='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';
CREATE USER 'chess_master' IDENTIFIED BY 'qwerty';

GRANT ALL ON `default_schema`.* TO 'chess_master';
GRANT ALL ON `CHESS_DB`.* TO 'chess_master';

SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;
